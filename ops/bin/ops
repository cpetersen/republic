#!/usr/bin/env ruby

require "aws-sdk"
require "barge"
require "json"
require "net/ssh"
require "redis"
require "thor"

module Ops
  class CommonTasks < Thor
    no_tasks do
      def cluster_name
        "general"
      end

      def redis
        @redis ||= Redis.new(url: ENV["REDIS_URL"])
      end

      def barge
        @barge ||= Barge::Client.new(access_token: ENV["DIGITALOCEAN_TOKEN"])
      end

      def keys
        @keys ||= redis.hkeys(cluster_type_name)
      end

      def delete_keys_for(droplet_id)
        redis.hdel(cluster_type_name, droplet_id)
        # redis.hdel("#{cluster_type_name}-provisioned-at", droplet_id)
        # redis.hdel("#{cluster_type_name}-provisioned-status", droplet_id)
      end

      def ssh_exec!(ssh, command)
        stdout_data = ""
        stderr_data = ""
        exit_code = nil
        exit_signal = nil
        ssh.open_channel do |channel|
          channel.exec(command) do |ch, success|
            unless success
              abort "FAILED: couldn't execute command (ssh.channel.exec)"
            end
            channel.on_data do |ch,data|
              stdout_data+=data
            end

            channel.on_extended_data do |ch,type,data|
              stderr_data+=data
            end

            channel.on_request("exit-status") do |ch,data|
              exit_code = data.read_long
            end

            channel.on_request("exit-signal") do |ch, data|
              exit_signal = data.read_long
            end
          end
        end
        ssh.loop
        [stdout_data, stderr_data, exit_code, exit_signal]
      end
    end
  end

  class GeneralCluster < CommonTasks
    desc "add N", "Add machines to the cluster"
    def add(n)
      n.to_i.times do
        redis.incr("#{cluster_type_name}-counter")
        i = redis.get("#{cluster_type_name}-counter")
        name = "#{cluster_type_name}-node-#{i}"
        puts "Launching #{name}"
        result = barge.droplet.create(droplet_options.merge(name: name))
        redis.hset(cluster_type_name, result.droplet.id, result.droplet.name)
        redis.hset("#{cluster_type_name}-name-to-id", result.droplet.name, result.droplet.id)
        redis.hset("#{cluster_type_name}-name-to-ip", result.droplet.name, result.droplet.networks["v4"].first.ip_address)
      end
      # update_dns if respond_to?(:update_dns)
    end

    desc "status", "Check the status of machines in the cluster"
    method_option :check_ssh, type: :boolean, aliases: "-s", default: false
    def status
      puts "No #{type_name} machines" if machines.empty?
      machines(options[:check_ssh]).each do |machine|
        if machine[:status] == "not_found"
          puts "#{machine[:name]} :: Not Found"
        else
          puts "#{machine[:name]} :: #{machine[:ip_address]} :: #{machine[:id]} :: #{machine[:status]}"
        end
      end
    end

    desc "destroy", "Destroy the machines in the cluster"
    def destroy(*names)
      puts "No #{type_name} machines" if keys.empty?
      keys.each do |droplet_id|
        droplet_name = redis.hget(cluster_type_name, droplet_id)
        result = barge.droplet.destroy(droplet_id)
        if result.success?
          puts "Destroyed #{droplet_name}"
          delete_keys_for(droplet_id)
        else
          if result.id=="not_found"
            delete_keys_for(droplet_id)
          end
          puts "Unabled to destroy #{droplet_name}, [#{result.id}] [#{result.message}]"
        end
      end
      # update_dns if respond_to?(:update_dns)
    end

    no_tasks do
      def cluster_type_name
        "#{cluster_name}-#{type_name}"
      end

      def type_name
        raise "Error: Please set type_name in the subclass"
      end

      def machines(check_ssh=false)
        @machines ||= keys.collect do |droplet_id|
          machine = {id: droplet_id}
          machine[:name] = redis.hget(cluster_type_name, droplet_id)
          machine[:type] = type_name
          droplet = barge.droplet.show(droplet_id)
          if droplet && droplet.droplet
            machine[:ip_address] = droplet.droplet.networks["v4"].first.ip_address
            machine[:status] = droplet.droplet.status
            if(check_ssh && machine[:status]=="active")
              begin
                Net::SSH.start(machine[:ip_address], 'root') do |ssh|
                  ssh_exec!(ssh, "ls")
                end
              rescue
                machine[:status] = "waiting for ssh"
              end
            end
          else
            machine[:status] = "not_found"
          end
          machine
        end
      end

      def droplet_options
        {
          region: "nyc2",
          size: "512mb",
          image: "ubuntu-14-04-x64",
          ssh_keys: [ENV["DIGITALOCEAN_KEY_ID"].to_i],
          backups: false,
          ipv6: true,
          user_data: nil,
          private_networking: nil
        }.merge(droplet_modifications)
      end

      def droplet_modifications
        {}
      end
    end
  end

  class Platform < GeneralCluster
    desc "dns", "Update the dns records"
    def dns
      update_dns
    end

    no_tasks do
      def type_name
        "platform"
      end

      def route53
        @route53 ||= AWS::Route53.new(access_key_id: ENV["AWS_ACCESS_KEY_ID"], secret_access_key: ENV["AWS_SECRET_ACCESS_KEY"])
      end

      # Resouce Record Sets
      def rrsets
        @rrsets ||= AWS::Route53::HostedZone.new(ENV["AWS_HOSTED_ZONE_ID"]).rrsets
      end

      def update_dns
        url = "#{type_name}.nestedset.com."
        rrset = rrsets[url, "A"]
        resource_records = machines.collect { |m| { value: m[:ip_address] }}
        if resource_records.empty?
          rrset.delete if rrset.exists?
        else
          if rrset.exists?
            rrset.resource_records = resource_records
            rrset.update
          else
            rrset = rrsets.create(url, "A", ttl: 3600, resource_records: resource_records)
          end
        end
      end
    end
  end

  class Worker < GeneralCluster
    no_tasks do
      def type_name
        "worker"
      end
    end
  end

  class CLI < CommonTasks
    desc "platform [SUBCOMMAND]", "Manage the platform machines"
    subcommand "platform", Platform

    desc "worker [SUBCOMMAND]", "Manage the worker machines"
    subcommand "worker", Worker

    desc "status", "Get status of all machine groups"
    method_option :check_ssh, type: :boolean, aliases: "-s", default: false
    method_option :clean, type: :boolean, aliases: "-c", default: false
    def status
      # machines = machine_types.collect { |klazz| klazz.new.machines(options[:check_ssh]) }.flatten
      # puts "Nothing running" if machines.empty?
      nothing = true
      machine_types.each do |klazz|
        instance = klazz.new
        instance.machines(options[:check_ssh]).each do |machine|
          nothing = false
          if machine[:status] == "not_found"
            puts "#{machine[:name]} :: Not Found"
            instance.delete_keys_for(machine[:id]) if options[:clean]
          else
            puts "#{machine[:name]} :: #{machine[:ip_address]} :: #{machine[:id]} :: #{machine[:status]}"
          end
        end
      end
      puts "Nothing running" if nothing
    end

    desc "inventory", "Generate ansible inventory file in the current directory"
    def inventory
      create_inventory_file
    end

    desc "provision", "Provision the machines in the cluster"
    def provision
      create_inventory_file # Make sure inventory is up to date
      command = "ansible-playbook -i inventory provision.yml"
      puts "Running [#{command}]"
      shell_command(command)
    end

    desc "join", "Join the cluster"
    def join
      create_inventory_file # Make sure inventory is up to date
      platform_machines = Platform.new.machines
      command = "ansible-playbook -i inventory join.yml --extra-vars \"ip_address=#{platform_machines.first[:ip_address]}\""
      puts "Running [#{command}]"
      shell_command(command)
    end

    desc "destroy", "Destroy specific machines of any type in the cluster"
    method_option :all, type: :boolean, aliases: "-a", default: false
    def destroy(*args)
      machine_types.each do |type|
        cluster_type_name = "#{cluster_name}-#{type.name.split('::').last.downcase}"
        redis.hkeys(cluster_type_name).each do |droplet_id|
          droplet_name = redis.hget(cluster_type_name, droplet_id)
          if args.include?(droplet_name)
            result = barge.droplet.destroy(droplet_id)
            if result.success?
              puts "Destroyed #{droplet_name}"
              delete_keys_for(droplet_id)
            else
              if result.id=="not_found"
                delete_keys_for(droplet_id)
              end
              puts "Unabled to destroy #{droplet_name}, [#{result.id}] [#{result.message}]"
            end
          end
        end
      end
    end

    desc "destroy_all", "Destroy all machines of any type in the cluster"
    def destroy_all
      machine_types.each do |klazz|
        klazz.new.destroy
      end
      if File.exists?("inventory")
        puts "Removing inventory file"
        File.delete("inventory")
      else
        puts "No inventory file"
      end

      if File.exists?("#{ENV["HOME"]}/.ssh/ssh.d/4_platform")
        puts "Removing ssh config file"
        File.delete("#{ENV["HOME"]}/.ssh/ssh.d/4_platform")
      else
        puts "No ssh config file"
      end
    end

    desc "backup", "Backup redis connection"
    def backup
      result = {}
      redis.keys.each do |key|
        type = redis.type(key)
        result[key] = case type
        when "hash"
          redis.hgetall(key)
        when "string"
          redis.get(key)
        else

        end
      end
      File.open("redis.json", "w") do |file|
        file.puts result.to_json
      end
    end

    desc "config", "Setup client configuration for the platform"
    def config
      create_ssh_config
    end

    no_tasks do
      def machine_types
        [Platform, Worker]
      end

      def create_inventory_file
        File.open("inventory", "w") do |file|
          machine_types.each do |klazz|
            _machines = klazz.new.machines
            unless _machines.empty?
              file.puts "[#{klazz.name.split('::').last.downcase}]"
              _machines.each do |machine|
                file.puts "#{machine[:ip_address]} ansible_ssh_user=root"
              end
              file.puts ""
            end
          end
        end
      end

      def create_ssh_config
        File.open("#{ENV["HOME"]}/.ssh/ssh.d/4_platform", "w") do |file|
          machine_types.each do |klazz|
            machines = klazz.new.machines
            unless machines.empty?
              machines.each do |machine|
                file.puts "Host #{machine[:name]}"
                file.puts "\tHostname #{machine[:ip_address]}"
                file.puts "\tUser root"
                file.puts ""
                puts "Configured #{machine[:name]}"
              end
            end
          end
          file.puts ""
          file.puts ""
        end
      end

      def shell_command(command)
        output = []
        IO.popen(command).each do |line|
          puts line.chomp
          STDOUT.flush
          output << line.chomp
        end
        output
      end
    end
  end
end

Ops::CLI.start(ARGV)
