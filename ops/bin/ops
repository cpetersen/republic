#!/usr/bin/env ruby

require "thor"
require "barge"
require "redis"
require "net/ssh"

module Ops
  class GeneralCluster < Thor
    desc "add N", "Add machines to the cluster"
    def add(n)
      n.to_i.times do
        redis.incr("#{cluster_type_name}-counter")
        i = redis.get("#{cluster_type_name}-counter")
        name = "#{cluster_type_name}-node-#{i}"
        puts "Launching #{name}"
        result = barge.droplet.create(droplet_options.merge(name: name))
        redis.hset(cluster_type_name, result.droplet.id, result.droplet.name)
      end
    end

    desc "status", "Check the status of machines in the cluster"
    def status
      puts "None found" if keys.empty?
      keys.each do |droplet_id|
        droplet_name = redis.hget(cluster_type_name, droplet_id)
        result = barge.droplet.show(droplet_id)
        if result.id == "not_found"
          puts "#{droplet_name} :: Not Found"
        else
          puts "#{droplet_name} :: #{result.droplet.networks["v4"].first.ip_address} :: #{result.droplet.id} :: #{result.droplet.status}"
        end
      end
    end

    desc "destroy", "Destroy the machines in the cluster"
    def destroy
      puts "None found" if keys.empty?
      keys.each do |droplet_id|
        droplet_name = redis.hget(cluster_type_name, droplet_id)
        result = barge.droplet.destroy(droplet_id)
        if result.success?
          puts "Destroyed #{droplet_name}"
          delete_keys_for(droplet_id)
        else
          if result.id=="not_found"
            delete_keys_for(droplet_id)
          end
          puts "Unabled to destroy #{droplet_name}, [#{result.id}] [#{result.message}]"
        end
      end
    end

    no_tasks do
      def cluster_type_name
        "#{cluster_name}-#{type_name}"
      end

      def cluster_name
        "general"
      end

      def type_name
        raise "Error: Please set type_name in the subclass"
      end

      def redis
        @redis ||= Redis.new(url: ENV["REDIS_URL"])
      end

      def barge
        @barge ||= Barge::Client.new(access_token: ENV["DIGITALOCEAN_TOKEN"])
      end

      def keys
        @keys ||= redis.hkeys(cluster_type_name)
      end

      def delete_keys_for(droplet_id)
        redis.hdel(cluster_type_name, droplet_id)
        redis.hdel("#{cluster_type_name}-provisioned-at", droplet_id)
        redis.hdel("#{cluster_type_name}-provisioned-status", droplet_id)
      end

      def droplet_options
        {
          region: "nyc2",
          size: "512mb",
          image: "ubuntu-14-04-x64",
          ssh_keys: [ENV["DIGITALOCEAN_KEY_ID"].to_i],
          backups: false,
          ipv6: true,
          user_data: nil,
          private_networking: nil
        }.merge(droplet_modifications)
      end

      def droplet_modifications
        {}
      end

      # Credit: http://stackoverflow.com/questions/3386233/how-to-get-exit-status-with-rubys-netssh-library
      def ssh_exec!(ssh, command)
        stdout_data = ""
        stderr_data = ""
        exit_code = nil
        exit_signal = nil
        ssh.open_channel do |channel|
          channel.exec(command) do |ch, success|
            unless success
              abort "FAILED: couldn't execute command (ssh.channel.exec)"
            end
            channel.on_data do |ch,data|
              stdout_data+=data
            end

            channel.on_extended_data do |ch,type,data|
              stderr_data+=data
            end

            channel.on_request("exit-status") do |ch,data|
              exit_code = data.read_long
            end

            channel.on_request("exit-signal") do |ch, data|
              exit_signal = data.read_long
            end
          end
        end
        ssh.loop
        [stdout_data, stderr_data, exit_code, exit_signal]
      end
    end
  end

  class LoadBalancer < GeneralCluster
    no_tasks do
      def type_name
        raise "loadbalancer"
      end
    end
  end

  class Swarm < GeneralCluster
    desc "provision", "Provision the machines in the cluster"
    def provision
      provisioning_script = [
        # https://docs.docker.com/installation/ubuntulinux/
        "apt-get update",
        "sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 36A1D7869245C8950F966E92D8576A8BA88D21E9",
        "echo deb https://get.docker.com/ubuntu docker main > /etc/apt/sources.list.d/docker.list",
        "apt-get update",
        "apt-get -y install lxc-docker",
        # https://github.com/docker/swarm/
        "apt-get -y install golang",
        "mkdir -p /opt/gocode",
        "echo export GOPATH=/opt/gocode >> /etc/bash.bashrc",
        "echo export PATH=$PATH:/opt/gocode/bin >> /etc/bash.bashrc",
        "GOPATH=/opt/gocode go get -u github.com/docker/swarm"
      ]
      puts "None found" if keys.empty?
      keys.each do |droplet_id|
        droplet_name = redis.hget(cluster_type_name, droplet_id)
        result = barge.droplet.show(droplet_id)
        if result.id == "not_found"
          puts "#{droplet_name} :: Not Found"
        else
          ip_address = result.droplet.networks["v4"].first.ip_address
          status = result.droplet.status
          if status=="new"
            puts "Not ready #{droplet_name} :: #{ip_address} :: #{status}"
          elsif status=="active"
            begin
              error = false
              Net::SSH.start(ip_address, "root") do |ssh|
                puts "Provisioning #{droplet_name} :: #{ip_address}"
                provisioning_script.each do |command|
                  stdout_data, stderr_data, exit_code, exit_signal = ssh_exec!(ssh, command)
                  puts "Ran [#{exit_code}] [#{command}]"
                  unless exit_code == 0
                    error = true
                    break
                  end
                end
              end
              redis.hset("#{cluster_type_name}-provisioned-at", droplet_id, Time.now)
              redis.hset("#{cluster_type_name}-provisioned-status", droplet_id, (error ? "ERROR" : "OK"))
            rescue Errno::ECONNREFUSED
              puts "Not ready #{droplet_name} :: #{ip_address} :: waiting for ssh"
            end
          else
            puts "Unknown status #{droplet_name} :: #{ip_address} :: #{status}"
          end
        end
      end
    end

    no_tasks do
      def type_name
        raise "swarm"
      end
    end
  end

  class Database < GeneralCluster
    no_tasks do
      def type_name
        raise "database"
      end
    end
  end

  class CLI < Thor
    desc "load_balancer [SUBCOMMAND]", "manage the load balancers"
    subcommand "load_balancer", LoadBalancer

    desc "swarm [SUBCOMMAND]", "manage the swarm machines"
    subcommand "swarm", Swarm

    desc "database [SUBCOMMAND]", "manage the database machines"
    subcommand "database", Database
  end
end

Ops::CLI.start(ARGV)
