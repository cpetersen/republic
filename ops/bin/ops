#!/usr/bin/env ruby

require "aws-sdk"
require "barge"
require "thor"
require "redis"
require "net/ssh"

module Ops
  class GeneralCluster < Thor
    desc "add N", "Add machines to the cluster"
    def add(n)
      n.to_i.times do
        redis.incr("#{cluster_type_name}-counter")
        i = redis.get("#{cluster_type_name}-counter")
        name = "#{cluster_type_name}-node-#{i}"
        puts "Launching #{name}"
        result = barge.droplet.create(droplet_options.merge(name: name))
        redis.hset(cluster_type_name, result.droplet.id, result.droplet.name)
      end
      update_dns if respond_to?(:update_dns)
    end

    desc "status", "Check the status of machines in the cluster"
    def status
      puts "No #{type_name} machines" if machines.empty?
      machines.each do |machine|
        if machine[:status] == "not_found"
          puts "#{machine[:name]} :: Not Found"
        else
          puts "#{machine[:name]} :: #{machine[:ip_address]} :: #{machine[:id]} :: #{machine[:status]}"
        end
      end
    end

    # desc "test", "Little task for testing thor environment"
    # def test
    #   puts "TEST!"
    # end

    desc "destroy", "Destroy the machines in the cluster"
    def destroy
      puts "No #{type_name} machines" if keys.empty?
      keys.each do |droplet_id|
        droplet_name = redis.hget(cluster_type_name, droplet_id)
        result = barge.droplet.destroy(droplet_id)
        if result.success?
          puts "Destroyed #{droplet_name}"
          delete_keys_for(droplet_id)
        else
          if result.id=="not_found"
            delete_keys_for(droplet_id)
          end
          puts "Unabled to destroy #{droplet_name}, [#{result.id}] [#{result.message}]"
        end
      end
      update_dns if respond_to?(:update_dns)
    end

    no_tasks do
      def cluster_type_name
        "#{cluster_name}-#{type_name}"
      end

      def cluster_name
        "general"
      end

      def type_name
        raise "Error: Please set type_name in the subclass"
      end

      def machines
        @machines ||= keys.collect do |droplet_id|
          machine = {id: droplet_id}
          machine[:name] = redis.hget(cluster_type_name, droplet_id)
          machine[:type] = type_name
          droplet = barge.droplet.show(droplet_id)
          if droplet
            machine[:ip_address] = droplet.droplet.networks["v4"].first.ip_address
            machine[:status] = droplet.droplet.status
            machine[:provisioned_status] = redis.hget("#{cluster_type_name}-provisioned-status", droplet_id)
            machine[:provisioned_at] = redis.hget("#{cluster_type_name}-provisioned-at", droplet_id)
          else
            machine[:status] = "not_found"
          end
          machine
        end
      end

      def redis
        @redis ||= Redis.new(url: ENV["REDIS_URL"])
      end

      def barge
        @barge ||= Barge::Client.new(access_token: ENV["DIGITALOCEAN_TOKEN"])
      end

      def keys
        @keys ||= redis.hkeys(cluster_type_name)
      end

      def delete_keys_for(droplet_id)
        redis.hdel(cluster_type_name, droplet_id)
        redis.hdel("#{cluster_type_name}-provisioned-at", droplet_id)
        redis.hdel("#{cluster_type_name}-provisioned-status", droplet_id)
      end

      def droplet_options
        {
          region: "nyc2",
          size: "512mb",
          image: "ubuntu-14-04-x64",
          ssh_keys: [ENV["DIGITALOCEAN_KEY_ID"].to_i],
          backups: false,
          ipv6: true,
          user_data: nil,
          private_networking: nil
        }.merge(droplet_modifications)
      end

      def droplet_modifications
        {}
      end
    end
  end

  class Swarm < GeneralCluster
    desc "dns", "Update the dns records"
    def dns
      update_dns
    end

    no_tasks do
      def type_name
        "swarm"
      end

      def route53
        @route53 ||= AWS::Route53.new(access_key_id: ENV["AWS_ACCESS_KEY_ID"], secret_access_key: ENV["AWS_SECRET_ACCESS_KEY"])
      end

      # Resouce Record Sets
      def rrsets
        @rrsets ||= AWS::Route53::HostedZone.new(ENV["AWS_HOSTED_ZONE_ID"]).rrsets
      end

      def update_dns
        url = "#{type_name}.nestedset.com."
        rrset = rrsets[url, "A"]
        resource_records = machines.collect { |m| { value: m[:ip_address] }}
        if resource_records.empty?
          rrset.delete if rrset.exists?
        else
          if rrset.exists?
            rrset.resource_records = resource_records
            rrset.update
          else
            rrset = rrsets.create(url, "A", ttl: 3600, resource_records: resource_records)
          end
        end
      end
    end
  end

  class Database < GeneralCluster
    no_tasks do
      def type_name
        "database"
      end
    end
  end

  class CLI < Thor
    desc "swarm [SUBCOMMAND]", "Manage the swarm machines"
    subcommand "swarm", Swarm

    desc "database [SUBCOMMAND]", "Manage the database machines"
    subcommand "database", Database

    desc "status", "Get status of all machine groups"
    def status
      machines = [
                    Swarm.new.machines, 
                    Database.new.machines
                  ].flatten
      puts "Nothing running" if machines.empty?
      machines.each do |machine|
        if machine[:status] == "not_found"
          puts "#{machine[:name]} :: Not Found"
        else
          puts "#{machine[:name]} :: #{machine[:ip_address]} :: #{machine[:id]} :: #{machine[:status]}"
        end
      end
    end

    desc "inventory", "Generate ansible inventory file in the current directory"
    def inventory
      create_inventory_file
    end

    desc "provision", "Provision the machines in the cluster"
    def provision
      create_inventory_file # Make sure inventory is up to date
      command = "ansible-playbook -i inventory site.yml"
      puts "Running [#{command}]"
      # puts `${command}`
    end

    desc "destroy_all", "Destroy all machines of any type in the cluster"
    def destroy_all
      Swarm.new.destroy
      Database.new.destroy
      if File.exists?("inventory")
        puts "Removing inventory file"
        File.delete("inventory")
      else
        puts "No inventory file"
      end
    end

    no_tasks do
      def create_inventory_file
        File.open("inventory", "w") do |file|
          swarm = Swarm.new.machines
          unless swarm.empty?
            file.puts "[swarm]"
            swarm.each do |machine|
              file.puts "#{machine[:ip_address]} ansible_ssh_user=root"
            end
            file.puts ""
          end

          databases = Database.new.machines
          unless databases.empty?
            file.puts "[database]"
            databases.each do |machine|
              file.puts "#{machine[:ip_address]} ansible_ssh_user=root"
            end
            file.puts ""
          end
        end
      end
    end
  end
end

Ops::CLI.start(ARGV)
