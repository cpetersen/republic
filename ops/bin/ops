#!/usr/bin/env ruby

require "thor"
require "barge"
require "redis"
require "net/ssh"

module Ops
  class GeneralCluster < Thor
    desc "add N", "Add machines to the cluster"
    def add(n)
      n.to_i.times do
        redis.incr("#{cluster_type_name}-counter")
        i = redis.get("#{cluster_type_name}-counter")
        name = "#{cluster_type_name}-node-#{i}"
        puts "Launching #{name}"
        result = barge.droplet.create(droplet_options.merge(name: name))
        redis.hset(cluster_type_name, result.droplet.id, result.droplet.name)
      end
    end

    desc "status", "Check the status of machines in the cluster"
    def status
      puts "No #{type_name} machines" if machines.empty?
      machines.each do |machine|
        if machine[:status] == "not_found"
          puts "#{machine[:name]} :: Not Found"
        else
          puts "#{machine[:name]} :: #{machine[:ip_address]} :: #{machine[:id]} :: #{machine[:status]}"
        end
      end
    end

    desc "destroy", "Destroy the machines in the cluster"
    def destroy
      puts "No #{type_name} machines" if keys.empty?
      keys.each do |droplet_id|
        droplet_name = redis.hget(cluster_type_name, droplet_id)
        result = barge.droplet.destroy(droplet_id)
        if result.success?
          puts "Destroyed #{droplet_name}"
          delete_keys_for(droplet_id)
        else
          if result.id=="not_found"
            delete_keys_for(droplet_id)
          end
          puts "Unabled to destroy #{droplet_name}, [#{result.id}] [#{result.message}]"
        end
      end
    end

    no_tasks do
      def cluster_type_name
        "#{cluster_name}-#{type_name}"
      end

      def cluster_name
        "general"
      end

      def type_name
        raise "Error: Please set type_name in the subclass"
      end

      def machines
        @machines ||= keys.collect do |droplet_id|
          machine = {id: droplet_id}
          machine[:name] = redis.hget(cluster_type_name, droplet_id)
          machine[:type] = type_name
          droplet = barge.droplet.show(droplet_id)
          if droplet
            machine[:ip_address] = droplet.droplet.networks["v4"].first.ip_address
            machine[:status] = droplet.droplet.status
            machine[:provisioned_status] = redis.hget("#{cluster_type_name}-provisioned-status", droplet_id)
            machine[:provisioned_at] = redis.hget("#{cluster_type_name}-provisioned-at", droplet_id)
          else
            machine[:status] = "not_found"
          end
          machine
        end
      end

      def redis
        @redis ||= Redis.new(url: ENV["REDIS_URL"])
      end

      def barge
        @barge ||= Barge::Client.new(access_token: ENV["DIGITALOCEAN_TOKEN"])
      end

      def keys
        @keys ||= redis.hkeys(cluster_type_name)
      end

      def delete_keys_for(droplet_id)
        redis.hdel(cluster_type_name, droplet_id)
        redis.hdel("#{cluster_type_name}-provisioned-at", droplet_id)
        redis.hdel("#{cluster_type_name}-provisioned-status", droplet_id)
      end

      def droplet_options
        {
          region: "nyc2",
          size: "512mb",
          image: "ubuntu-14-04-x64",
          ssh_keys: [ENV["DIGITALOCEAN_KEY_ID"].to_i],
          backups: false,
          ipv6: true,
          user_data: nil,
          private_networking: nil
        }.merge(droplet_modifications)
      end

      def droplet_modifications
        {}
      end

      # Credit: http://stackoverflow.com/questions/3386233/how-to-get-exit-status-with-rubys-netssh-library
      # def ssh_exec!(ssh, command)
      #   stdout_data = ""
      #   stderr_data = ""
      #   exit_code = nil
      #   exit_signal = nil
      #   ssh.open_channel do |channel|
      #     channel.exec(command) do |ch, success|
      #       unless success
      #         abort "FAILED: couldn't execute command (ssh.channel.exec)"
      #       end
      #       channel.on_data do |ch,data|
      #         stdout_data+=data
      #       end

      #       channel.on_extended_data do |ch,type,data|
      #         stderr_data+=data
      #       end

      #       channel.on_request("exit-status") do |ch,data|
      #         exit_code = data.read_long
      #       end

      #       channel.on_request("exit-signal") do |ch, data|
      #         exit_signal = data.read_long
      #       end
      #     end
      #   end
      #   ssh.loop
      #   [stdout_data, stderr_data, exit_code, exit_signal]
      # end
    end
  end

  # class LoadBalancer < GeneralCluster
  #   no_tasks do
  #     def type_name
  #       "loadbalancer"
  #     end
  #   end
  # end

  class Swarm < GeneralCluster
    # desc "provision", "Provision the machines in the cluster"
    # def provision
    #   provisioning_script = [
    #     # https://docs.docker.com/installation/ubuntulinux/
    #     "apt-get update",
    #     "sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 36A1D7869245C8950F966E92D8576A8BA88D21E9",
    #     "echo deb https://get.docker.com/ubuntu docker main > /etc/apt/sources.list.d/docker.list",
    #     "apt-get update",
    #     "apt-get -y install lxc-docker",
    #     # https://github.com/docker/swarm/
    #     "apt-get -y install golang",
    #     "mkdir -p /opt/gocode",
    #     "echo export GOPATH=/opt/gocode >> /etc/bash.bashrc",
    #     "echo export PATH=$PATH:/opt/gocode/bin >> /etc/bash.bashrc",
    #     "GOPATH=/opt/gocode go get -u github.com/docker/swarm"
    #   ]
    #   puts "No #{type_name} machines" if keys.empty?
    #   keys.each do |droplet_id|
    #     droplet_name = redis.hget(cluster_type_name, droplet_id)
    #     result = barge.droplet.show(droplet_id)
    #     if result.id == "not_found"
    #       puts "#{droplet_name} :: Not Found"
    #     else
    #       ip_address = result.droplet.networks["v4"].first.ip_address
    #       status = result.droplet.status
    #       if status=="new"
    #         puts "Not ready #{droplet_name} :: #{ip_address} :: #{status}"
    #       elsif status=="active"
    #         begin
    #           error = false
    #           Net::SSH.start(ip_address, "root") do |ssh|
    #             puts "Provisioning #{droplet_name} :: #{ip_address}"
    #             provisioning_script.each do |command|
    #               stdout_data, stderr_data, exit_code, exit_signal = ssh_exec!(ssh, command)
    #               puts "Ran [#{exit_code}] [#{command}]"
    #               unless exit_code == 0
    #                 error = true
    #                 break
    #               end
    #             end
    #           end
    #           redis.hset("#{cluster_type_name}-provisioned-at", droplet_id, Time.now)
    #           redis.hset("#{cluster_type_name}-provisioned-status", droplet_id, (error ? "ERROR" : "OK"))
    #         rescue Errno::ECONNREFUSED
    #           puts "Not ready #{droplet_name} :: #{ip_address} :: waiting for ssh"
    #         end
    #       else
    #         puts "Unknown status #{droplet_name} :: #{ip_address} :: #{status}"
    #       end
    #     end
    #   end
    # end

    no_tasks do
      def type_name
        "swarm"
      end
    end
  end

  class Database < GeneralCluster
    no_tasks do
      def type_name
        "database"
      end
    end
  end

  class CLI < Thor
    # desc "load_balancer [SUBCOMMAND]", "Manage the load balancers"
    # subcommand "load_balancer", LoadBalancer

    desc "swarm [SUBCOMMAND]", "Manage the swarm machines"
    subcommand "swarm", Swarm

    desc "database [SUBCOMMAND]", "Manage the database machines"
    subcommand "database", Database

    desc "status", "Get status of all machine groups"
    def status
      machines = [
                    # LoadBalancer.new.machines, 
                    Swarm.new.machines, 
                    Database.new.machines
                  ].flatten
      puts "Nothing running" if machines.empty?
      machines.each do |machine|
        if machine[:status] == "not_found"
          puts "#{machine[:name]} :: Not Found"
        else
          puts "#{machine[:name]} :: #{machine[:ip_address]} :: #{machine[:id]} :: #{machine[:status]}"
        end
      end
    end

    desc "inventory", "Generate ansible inventory file in the current directory"
    def inventory
      create_inventory_file
    end

    desc "provision", "Provision the machines in the cluster"
    def provision
      create_inventory_file # Make sure inventory is up to date
      command = "ansible-playbook -i inventory site.yml"
      puts "Running [#{command}]"
      # puts `${command}`
    end

    desc "destroy_all", "Destroy all machines of any type in the cluster"
    def destroy_all
      # LoadBalancer.new.destroy
      Swarm.new.destroy
      Database.new.destroy
      if File.exists?("inventory")
        puts "Removing inventory file"
        File.delete("inventory")
      else
        puts "No inventory file"
      end
    end

    no_tasks do
      def create_inventory_file
        File.open("inventory", "w") do |file|
          # load_balancers = LoadBalancer.new.machines
          # unless load_balancers.empty?
          #   file.puts "[load_balancer]"
          #   load_balancers.each do |machine|
          #     file.puts "#{machine[:ip_address]} ansible_ssh_user=root"
          #   end
          #   file.puts ""
          # end

          swarm = Swarm.new.machines
          unless swarm.empty?
            file.puts "[swarm]"
            swarm.each do |machine|
              file.puts "#{machine[:ip_address]} ansible_ssh_user=root"
            end
            file.puts ""
          end

          databases = Database.new.machines
          unless databases.empty?
            file.puts "[database]"
            databases.each do |machine|
              file.puts "#{machine[:ip_address]} ansible_ssh_user=root"
            end
            file.puts ""
          end
        end
      end
    end
  end
end

Ops::CLI.start(ARGV)
